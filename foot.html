<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Football Platform Duel</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chivo:wght@700&display=swap');

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1e1e2d 0%, #0a0a1a 100%);
            font-family: 'Chivo', sans-serif;
            color: #fff;
            overflow: hidden;
        }

        .game-container {
            width: 90%;
            max-width: 800px;
            background-color: #1e1e2d;
            border: 8px solid #3a3a50;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .score-board {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: #2b2b40;
            border-radius: 8px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .score {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #score-blue {
            color: #40a0ff;
        }

        #score-red {
            color: #ff5050;
        }

        .controls-info {
            background-color: #2b2b40;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.8rem;
            text-align: center;
            color: #aaa;
        }

        .controls-info p {
            margin: 5px 0;
        }

        canvas {
            display: block;
            background: linear-gradient(to bottom, #2c9a3a, #1f7828); /* Green Pitch */
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            cursor: pointer;
        }
    </style>
</head>
<body>

<div class="game-container">
    <div class="score-board">
        <div id="score-blue" class="score">
            <span style="font-size: 1.2rem;">BLUE</span>
            <span id="blue-score">0</span>
        </div>
        <div class="score">
            <span style="font-size: 1.2rem; color: #fff;">-</span>
        </div>
        <div id="score-red" class="score">
            <span id="red-score">0</span>
            <span style="font-size: 1.2rem;">RED</span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="controls-info">
        <p>BLUE (Left): [A] Move Left, [D] Move Right, [W] Jump</p>
        <p>RED (Right): [←] Move Left, [→] Move Right, [↑] Jump</p>
        <p>Click on the game area to start/reset after a goal!</p>
    </div>
</div>

<script>
    // --- CANVAS SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBlueElement = document.getElementById('blue-score');
    const scoreRedElement = document.getElementById('red-score');

    // Make canvas responsive
    let CANVAS_WIDTH;
    let CANVAS_HEIGHT;
    
    // FIX: Initialize player and ball variables here to avoid "Cannot access 'player1' before initialization" 
    // when resizeCanvas is called immediately below.
    let player1 = null; 
    let player2 = null; 
    let ball = null;

    function resizeCanvas() {
        CANVAS_WIDTH = canvas.clientWidth;
        CANVAS_HEIGHT = CANVAS_WIDTH * 0.5625; // Maintain 16:9 aspect ratio
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        // Re-set initial positions after resize
        if (player1 && player2 && ball) {
            setupGame();
        }
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- GAME CONSTANTS ---
    const GRAVITY = 0.5;
    const DRAG = 0.98;
    // These are initialized with placeholder values as they rely on CANVAS_WIDTH, which is dynamic.
    // They will be dynamically accessed or overwritten in Player/Ball constructors and update logic.
    const PLAYER_SPEED = 5;
    const JUMP_FORCE = 12;

    // --- GAME STATE ---
    let score = { blue: 0, red: 0 };
    let keys = {};
    let isGoalScored = false;
    let lastTime = 0;

    // --- UTILITY FUNCTIONS ---

    // Simple distance calculation
    function dist(x1, y1, x2, y2) {
        const dx = x1 - x2;
        const dy = y1 - y2;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // --- GAME OBJECTS ---

    class Player {
        constructor(x, color, controls) {
            // Recalculate dynamic dimensions needed for initial setup
            const currentPlayerRadius = CANVAS_WIDTH * 0.035;
            const currentGroundY = CANVAS_HEIGHT - 30;
            
            this.x = x;
            this.y = currentGroundY - currentPlayerRadius;
            this.vx = 0;
            this.vy = 0;
            this.radius = currentPlayerRadius; 
            this.color = color;
            this.onGround = true;
            this.controls = controls; // { left, right, jump }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.closePath();

            // Eyes (simple white dots for visual appeal)
            ctx.beginPath();
            ctx.arc(this.x, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.closePath();
            ctx.shadowBlur = 0;
        }

        update() {
            // Apply controls
            if (keys[this.controls.left]) {
                this.vx = -PLAYER_SPEED;
            } else if (keys[this.controls.right]) {
                this.vx = PLAYER_SPEED;
            } else {
                this.vx *= DRAG * 0.9; // Apply horizontal drag
            }

            if (keys[this.controls.jump] && this.onGround) {
                this.vy = -JUMP_FORCE;
                this.onGround = false;
            }

            // Apply gravity
            this.vy += GRAVITY;

            // Update position
            this.x += this.vx;
            this.y += this.vy;

            // Recalculate dynamic dimensions needed for boundary checks
            const currentGroundY = CANVAS_HEIGHT - 30;
            const currentGoalWidth = CANVAS_WIDTH * 0.05;

            // Ground collision
            if (this.y + this.radius > currentGroundY) {
                this.y = currentGroundY - this.radius;
                this.vy = 0;
                this.onGround = true;
                this.vx *= DRAG * 0.5; // High ground friction
            }

            // Wall boundary (players cannot enter goal areas or go off screen)
            const minX = currentGoalWidth + this.radius;
            const maxX = CANVAS_WIDTH - currentGoalWidth - this.radius;
            
            if (this.x < minX) this.x = minX;
            if (this.x > maxX) this.x = maxX;
        }
    }

    class Ball {
        constructor() {
            // Recalculate dynamic dimensions needed for initial setup
            const currentBallRadius = CANVAS_WIDTH * 0.015;
            this.radius = currentBallRadius;
            this.color = '#fff';
            this.reset();
        }

        reset() {
            const currentGroundY = CANVAS_HEIGHT - 30;
            this.x = CANVAS_WIDTH / 2;
            this.y = currentGroundY - this.radius * 3;
            this.vx = 0;
            this.vy = 0;
            this.onGround = false;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.closePath();
            ctx.shadowBlur = 0;
        }

        update() {
            // Apply gravity
            this.vy += GRAVITY * 0.7; // Slightly less gravity for a lighter ball

            // Apply drag (air resistance)
            this.vx *= DRAG;
            this.vy *= DRAG;

            // Update position
            this.x += this.vx;
            this.y += this.vy;

            // Recalculate dynamic dimensions needed for boundary/goal checks
            const currentGoalWidth = CANVAS_WIDTH * 0.05;
            const currentGroundY = CANVAS_HEIGHT - 30;
            const currentGoalHeight = CANVAS_HEIGHT * 0.4;
            
            // Ground collision
            if (this.y + this.radius > currentGroundY) {
                this.y = currentGroundY - this.radius;
                this.vy *= -0.8; // Bounce
                this.vx *= 0.9; // Ground friction
                if (Math.abs(this.vy) < 1) { // Stop small oscillations
                    this.vy = 0;
                    this.onGround = true;
                }
            } else {
                this.onGround = false;
            }

            // Wall collision (top and center wall)
            if (this.x - this.radius < 0 || this.x + this.radius > CANVAS_WIDTH) {
                this.vx *= -0.9;
                // Move ball back slightly to prevent sticking
                this.x = this.x - this.radius < 0 ? this.radius : CANVAS_WIDTH - this.radius;
            }
            if (this.y - this.radius < 0) {
                this.y = this.radius;
                this.vy *= -0.9;
            }

            // Goal check
            if (this.y + this.radius > currentGroundY - currentGoalHeight && this.y + this.radius < currentGroundY) {
                if (this.x - this.radius < currentGoalWidth) {
                    // Goal for Red team (Blue's goal)
                    scoreGoal('red');
                } else if (this.x + this.radius > CANVAS_WIDTH - currentGoalWidth) {
                    // Goal for Blue team (Red's goal)
                    scoreGoal('blue');
                }
            }
        }
    }

    // --- COLLISION LOGIC ---

    function checkCollisions() {
        checkPlayerBall(player1);
        checkPlayerBall(player2);
    }

    function checkPlayerBall(player) {
        const dx = player.x - ball.x;
        const dy = player.y - ball.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = player.radius + ball.radius;

        if (distance < minDistance) {
            // Collision detected
            const angle = Math.atan2(dy, dx);
            const overlap = minDistance - distance;

            // 1. Resolve overlap (push ball out)
            ball.x -= overlap * Math.cos(angle);
            ball.y -= overlap * Math.sin(angle);

            // 2. Apply impulse (transfer velocity)
            const impulseStrength = 1.3; // How much player's movement affects the ball
            
            // Calculate relative velocity
            const relVx = ball.vx - player.vx;
            const relVy = ball.vy - player.vy;
            
            // Velocity along the collision normal
            const normalX = dx / distance;
            const normalY = dy / distance;
            const velocityDotNormal = relVx * normalX + relVy * normalY;

            // Only apply impulse if objects are moving toward each other
            if (velocityDotNormal < 0) {
                const impulse = -velocityDotNormal * impulseStrength;
                ball.vx += impulse * normalX;
                ball.vy += impulse * normalY;

                // Add player's velocity boost
                ball.vx += player.vx * 0.5;
                ball.vy += player.vy * 0.5;
            }
        }
    }

    // --- GAME FLOW ---

    function setupGame() {
        // Initialize players at starting positions
        const p1X = CANVAS_WIDTH / 4;
        const p2X = CANVAS_WIDTH * 3 / 4;
        
        // Player/Ball objects now correctly calculate their size/position based on current CANVAS_WIDTH/HEIGHT in their constructors
        player1 = new Player(p1X, '#40a0ff', { left: 'a', right: 'd', jump: 'w' }); // Blue
        player2 = new Player(p2X, '#ff5050', { left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp' }); // Red
        ball = new Ball();
    }

    function scoreGoal(team) {
        if (isGoalScored) return;

        isGoalScored = true;
        score[team]++;
        updateScoreBoard();
        
        // Show celebration text
        const goalText = (team === 'blue' ? 'BLUE GOAL!' : 'RED GOAL!');
        ctx.font = '72px Chivo';
        ctx.textAlign = 'center';
        ctx.fillStyle = team === 'blue' ? '#40a0ff' : '#ff5050';
        ctx.fillText(goalText, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 50);

        // Prompt to reset
        ctx.font = '30px Chivo';
        ctx.fillStyle = '#fff';
        ctx.fillText('Click to Continue', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
    }

    function updateScoreBoard() {
        scoreBlueElement.textContent = score.blue;
        scoreRedElement.textContent = score.red;
    }

    // --- DRAWING ---

    function drawField() {
        // Recalculate dependent variables inside drawField to handle dynamic resizing
        const currentGoalWidth = CANVAS_WIDTH * 0.05;
        const currentGoalHeight = CANVAS_HEIGHT * 0.4;
        const currentGroundY = CANVAS_HEIGHT - 30;

        // Goal Areas (Nets)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        
        // Blue Goal (Left)
        ctx.fillRect(0, currentGroundY - currentGoalHeight, currentGoalWidth, currentGoalHeight);
        // Red Goal (Right)
        ctx.fillRect(CANVAS_WIDTH - currentGoalWidth, currentGroundY - currentGoalHeight, currentGoalWidth, currentGoalHeight);

        // Ground/Platform
        ctx.fillStyle = '#111';
        ctx.fillRect(0, currentGroundY, CANVAS_WIDTH, CANVAS_HEIGHT - currentGroundY);

        // Center Line (Dashed)
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 10]);
        ctx.moveTo(CANVAS_WIDTH / 2, 0);
        ctx.lineTo(CANVAS_WIDTH / 2, currentGroundY);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash
        
        // Center Circle
        ctx.beginPath();
        ctx.arc(CANVAS_WIDTH / 2, currentGroundY - 50, 40, 0, Math.PI * 2);
        ctx.stroke();
        
        // Goal Line (to show goal boundary)
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(currentGoalWidth, currentGroundY);
        ctx.lineTo(currentGoalWidth, currentGroundY - currentGoalHeight);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(CANVAS_WIDTH - currentGoalWidth, currentGroundY);
        ctx.lineTo(CANVAS_WIDTH - currentGoalWidth, currentGroundY - currentGoalHeight);
        ctx.stroke();
    }

    // --- GAME LOOP ---

    function gameLoop(currentTime) {
        if (!isGoalScored) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawField();

            // Update and draw game objects
            player1.update();
            player2.update();
            ball.update();

            checkCollisions();

            player1.draw();
            player2.draw();
            ball.draw();
        }

        requestAnimationFrame(gameLoop);
    }

    // --- INPUT HANDLING ---

    document.addEventListener('keydown', (e) => {
        keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    canvas.addEventListener('click', () => {
        if (isGoalScored) {
            isGoalScored = false;
            // Re-set player positions correctly using setupGame
            setupGame();
            
            player1.vx = player2.vx = 0;
            player1.vy = player2.vy = 0;
            lastTime = performance.now(); // Reset time to prevent large jumps
        }
    });

    // --- START GAME ---
    setupGame();
    updateScoreBoard();
    requestAnimationFrame(gameLoop);
</script>

</body>
</html>

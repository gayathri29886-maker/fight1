<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Obby: The Long Run</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0fdf4;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            background-color: #ffffff;
            border: 8px solid #365314;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 16px;
            max-width: 800px; /* Max display width */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background-color: #e0f2fe;
            border: 4px solid #365314;
            border-radius: 8px;
            touch-action: manipulation;
        }
        .controls, .status {
            margin-top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .control-button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 700;
            background-color: #65a30d;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 0 #4d7c0f;
            transition: background-color 0.1s, box-shadow 0.1s, transform 0.1s;
        }
        .control-button:active {
            background-color: #4d7c0f;
            box-shadow: 0 0 0 #4d7c0f;
            transform: translateY(4px);
        }
        .control-button:disabled {
            background-color: #9ca3af;
            box-shadow: none;
            transform: translateY(0);
            cursor: not-allowed;
        }
        @media (max-width: 600px) {
            .controls {
                justify-content: space-around;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <h1 class="text-3xl font-bold text-center text-green-800 mb-4">Stickman Obby: The Long Run Challenge</h1>
    <canvas id="gameCanvas" width="700" height="450"></canvas>

    <div class="status mt-4 w-full">
        <p id="message" class="text-lg font-semibold text-green-700">Use A/D or Left/Right Arrows to move, Space/W/Up Arrow to jump!</p>
    </div>

    <div class="controls mt-4">
        <button id="resetButton" class="control-button w-full" disabled>Play Again</button>
    </div>

    <!-- Mobile Controls for touch -->
    <div class="controls mt-4 sm:hidden justify-center space-x-4">
        <button id="mobileLeft" class="control-button px-6 py-3">◀️ Left</button>
        <button id="mobileJump" class="control-button px-6 py-3">⬆️ Jump</button>
        <button id="mobileRight" class="control-button px-6 py-3">▶️ Right</button>
    </div>
</div>

<script>
    // --- Global Variables and Constants ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageElement = document.getElementById('message');
    const resetButton = document.getElementById('resetButton');

    // Display size (fixed size for viewport)
    const VIEWPORT_WIDTH = 700;
    const VIEWPORT_HEIGHT = 450;
    canvas.width = VIEWPORT_WIDTH;
    canvas.height = VIEWPORT_HEIGHT;

    // The entire game world size (much longer)
    const WORLD_WIDTH = 3000;
    const WORLD_HEIGHT = 450;

    // Game Physics Constants
    const GRAVITY = 0.6;
    const JUMP_FORCE = -13;
    const SPEED = 5;

    // Game State
    let isRunning = true;
    let hasWon = false;
    let animationFrameId;
    let cameraX = 0; // The camera offset for scrolling

    // Player Object
    let PLAYER = {
        x: 50,
        y: WORLD_HEIGHT - 60,
        width: 20,
        height: 40,
        velocityX: 0,
        velocityY: 0,
        onGround: false,
        isJumping: false,
        color: '#1e3a8a'
    };

    // Input Tracking
    const KEYS = { left: false, right: false, jump: false };

    // Platform Types
    const PLATFORM_TYPE = {
        NORMAL: 'normal',
        HAZARD: 'hazard',
        MOVING: 'moving', // New type
        GOAL: 'goal'
    };

    // Level Definition (The Extended Obby!)
    // Note: 'startX', 'endX', and 'speed' are used only for MOVING platforms.
    const LEVEL = [
        // Start Zone
        { x: 0, y: WORLD_HEIGHT - 20, w: 200, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Gap 1 & High Jump
        { x: 250, y: WORLD_HEIGHT - 80, w: 100, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        
        // Hazard 1: Lava Pit
        { x: 380, y: WORLD_HEIGHT - 20, w: 150, h: 20, type: PLATFORM_TYPE.HAZARD, color: '#ef4444' },

        // Steep Ascent 
        { x: 550, y: WORLD_HEIGHT - 120, w: 50, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        { x: 650, y: WORLD_HEIGHT - 200, w: 50, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // **SECTION 2: Moving Platforms**
        // Gap 3
        { x: 800, y: WORLD_HEIGHT - 250, w: 80, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Moving Platform 1 (Horizontal)
        { x: 950, y: WORLD_HEIGHT - 200, w: 120, h: 20, type: PLATFORM_TYPE.MOVING, color: '#fb923c', startX: 900, endX: 1200, speed: 2, currentDir: 1 },

        // Drop down to Ground
        { x: 1300, y: WORLD_HEIGHT - 100, w: 150, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Hazard 2: Long Spike Crawl
        { x: 1500, y: WORLD_HEIGHT - 20, w: 300, h: 20, type: PLATFORM_TYPE.HAZARD, color: '#ef4444' },

        // **SECTION 3: Vertical Challenge**
        // Staircase to high elevation
        { x: 1900, y: WORLD_HEIGHT - 80, w: 60, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        { x: 2000, y: WORLD_HEIGHT - 160, w: 60, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        { x: 2100, y: WORLD_HEIGHT - 240, w: 60, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Moving Platform 2 (Vertical - for a tricky jump)
        { x: 2300, y: WORLD_HEIGHT - 300, w: 50, h: 20, type: PLATFORM_TYPE.MOVING, color: '#fb923c', startY: WORLD_HEIGHT - 350, endY: WORLD_HEIGHT - 150, speed: 1.5, currentDir: 1, isVertical: true },

        // Final Hazard Skip
        { x: 2500, y: WORLD_HEIGHT - 20, w: 100, h: 20, type: PLATFORM_TYPE.HAZARD, color: '#ef4444' },

        // Final Goal Platform
        { x: WORLD_WIDTH - 200, y: WORLD_HEIGHT - 180, w: 200, h: 20, type: PLATFORM_TYPE.GOAL, color: '#facc15' },
    ];


    // --- Game Logic Functions ---

    function resetGame() {
        PLAYER.x = 50;
        PLAYER.y = WORLD_HEIGHT - 60;
        PLAYER.velocityX = 0;
        PLAYER.velocityY = 0;
        PLAYER.onGround = false;
        PLAYER.isJumping = false;
        cameraX = 0; // Reset camera

        isRunning = true;
        hasWon = false;
        messageElement.textContent = "Use A/D or Left/Right Arrows to move, Space/W/Up Arrow to jump!";
        messageElement.classList.remove('text-red-600', 'text-yellow-600');
        messageElement.classList.add('text-green-700');
        resetButton.disabled = true;

        // Reset moving platforms to their starting positions
        LEVEL.forEach(p => {
            if (p.type === PLATFORM_TYPE.MOVING) {
                p.x = p.startX || p.x;
                p.y = p.startY || p.y;
                p.currentDir = 1; // Start moving in positive direction
            }
        });

        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        gameLoop();
    }

    function checkCollision(objA, objB) {
        return objA.x < objB.x + objB.w &&
               objA.x + objA.width > objB.x &&
               objA.y < objB.y + objB.h &&
               objA.y + objA.height > objB.y;
    }

    function updateMovingPlatforms() {
        for (const platform of LEVEL) {
            if (platform.type === PLATFORM_TYPE.MOVING) {
                if (platform.isVertical) {
                    // Vertical Movement Logic
                    platform.y += platform.speed * platform.currentDir;

                    if (platform.currentDir === 1 && platform.y >= platform.endY) {
                        platform.currentDir = -1; // Reverse direction
                        platform.y = platform.endY;
                    } else if (platform.currentDir === -1 && platform.y <= platform.startY) {
                        platform.currentDir = 1; // Reverse direction
                        platform.y = platform.startY;
                    }
                } else {
                    // Horizontal Movement Logic
                    platform.x += platform.speed * platform.currentDir;

                    if (platform.currentDir === 1 && platform.x + platform.w >= platform.endX) {
                        platform.currentDir = -1; // Reverse direction
                        platform.x = platform.endX - platform.w;
                    } else if (platform.currentDir === -1 && platform.x <= platform.startX) {
                        platform.currentDir = 1; // Reverse direction
                        platform.x = platform.startX;
                    }
                }
            }
        }
    }

    function updateGame() {
        if (!isRunning || hasWon) return;

        // Update Moving Platforms before player movement
        updateMovingPlatforms();

        // 1. Handle Input & Gravity
        PLAYER.velocityX = 0;
        if (KEYS.left) { PLAYER.velocityX = -SPEED; }
        if (KEYS.right) { PLAYER.velocityX = SPEED; }
        PLAYER.velocityY += GRAVITY;

        // 2. Handle Jumping
        if (KEYS.jump && PLAYER.onGround && !PLAYER.isJumping) {
            PLAYER.velocityY = JUMP_FORCE;
            PLAYER.onGround = false;
            PLAYER.isJumping = true;
            // Short timeout to prevent immediate multiple jumps
            setTimeout(() => PLAYER.isJumping = false, 100);
        } else if (!KEYS.jump) {
            PLAYER.isJumping = false;
        }

        // 3. Update Position (Tentative move)
        PLAYER.x += PLAYER.velocityX;
        PLAYER.y += PLAYER.velocityY;

        // 4. Collision Detection and Response
        PLAYER.onGround = false;

        for (const platform of LEVEL) {
            const playerBox = { x: PLAYER.x, y: PLAYER.y, width: PLAYER.width, height: PLAYER.height };

            if (checkCollision(playerBox, platform)) {
                // HAZARD/GOAL CHECK
                if (platform.type === PLATFORM_TYPE.HAZARD) {
                    gameOver("You melted in the lava! Game Over.");
                    return;
                }
                if (platform.type === PLATFORM_TYPE.GOAL) {
                    winGame();
                    return;
                }

                // NORMAL & MOVING PLATFORM COLLISION (LANDING ONLY)
                const previousY = PLAYER.y - PLAYER.velocityY;
                const previousBottom = previousY + PLAYER.height;

                if (previousBottom <= platform.y && PLAYER.velocityY >= 0) {
                    PLAYER.y = platform.y - PLAYER.height; // Snap to the top
                    PLAYER.velocityY = 0; // Stop vertical movement
                    PLAYER.onGround = true;

                    // Carry the player with the moving platform
                    if (platform.type === PLATFORM_TYPE.MOVING) {
                        if (platform.isVertical) {
                            // Player stands still relative to X on vertical platforms
                            // (No horizontal shift from the platform itself)
                        } else {
                            // Apply platform's horizontal velocity to the player
                            PLAYER.x += platform.speed * platform.currentDir;
                        }
                    }
                }
            }
        }

        // 5. World Boundaries Check & Camera Update
        if (PLAYER.x < 0) {
            PLAYER.x = 0;
        }
        if (PLAYER.x + PLAYER.width > WORLD_WIDTH) {
            PLAYER.x = WORLD_WIDTH - PLAYER.width;
        }
        
        // Update Camera (Center the camera on the player, but clamp to world edges)
        cameraX = PLAYER.x - VIEWPORT_WIDTH / 2;
        cameraX = Math.max(0, cameraX); // Cannot scroll past the left edge
        cameraX = Math.min(WORLD_WIDTH - VIEWPORT_WIDTH, cameraX); // Cannot scroll past the right edge


        // 6. Fall Off World Check (Game Over)
        if (PLAYER.y > WORLD_HEIGHT) {
            gameOver("You fell into the abyss! Game Over.");
        }
    }

    // --- Drawing Functions ---

    function drawStickman(ctx, player) {
        const cx = player.x + player.width / 2; // Center X
        const headRadius = 8;
        const bodyY = player.y + headRadius * 2;
        const bodyHeight = player.height - headRadius * 2 - 5;

        ctx.strokeStyle = player.color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';

        // Head
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(cx, player.y + headRadius, headRadius, 0, Math.PI * 2);
        ctx.fill();

        // Body
        ctx.beginPath();
        ctx.moveTo(cx, bodyY);
        ctx.lineTo(cx, bodyY + bodyHeight);
        ctx.stroke();

        // Arms
        ctx.beginPath();
        ctx.moveTo(cx - 5, bodyY + 10);
        ctx.lineTo(cx + 5, bodyY + 10);
        ctx.stroke();

        // Legs
        const footY = player.y + player.height;
        ctx.beginPath();
        ctx.moveTo(cx, bodyY + bodyHeight);
        ctx.lineTo(cx - 5, footY);
        ctx.moveTo(cx, bodyY + bodyHeight);
        ctx.lineTo(cx + 5, footY);
        ctx.stroke();
    }

    function drawPlatform(ctx, p) {
        ctx.beginPath();
        ctx.rect(p.x, p.y, p.w, p.h);

        // Styling based on type
        if (p.type === PLATFORM_TYPE.HAZARD) {
            ctx.fillStyle = '#f87171'; // Red/Lava
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 10;
        } else if (p.type === PLATFORM_TYPE.GOAL) {
            ctx.fillStyle = '#fcd34d'; // Gold/Goal
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 10;
        } else if (p.type === PLATFORM_TYPE.MOVING) {
             ctx.fillStyle = '#fb923c'; // Orange/Moving
             ctx.shadowColor = '#f97316';
             ctx.shadowBlur = 8;
        }
        else {
            ctx.fillStyle = p.color;
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }
        ctx.fill();

        // Draw detail for hazards (spikes)
        if (p.type === PLATFORM_TYPE.HAZARD) {
            ctx.fillStyle = '#a1a1aa'; // Gray spikes
            const spikeSize = 8;
            for (let i = 0; i < p.w / spikeSize; i++) {
                ctx.beginPath();
                ctx.moveTo(p.x + i * spikeSize, p.y);
                ctx.lineTo(p.x + i * spikeSize + spikeSize / 2, p.y - spikeSize);
                ctx.lineTo(p.x + (i + 1) * spikeSize, p.y);
                ctx.fill();
            }
        }
    }

    function drawGame() {
        // Clear canvas and draw sky background
        ctx.clearRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
        ctx.fillStyle = '#e0f2fe';
        ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

        // --- Start Camera/Viewport Scroll ---
        // All subsequent draw commands will be offset by -cameraX
        ctx.save();
        ctx.translate(-cameraX, 0);

        // Draw Platforms
        LEVEL.forEach(p => drawPlatform(ctx, p));

        // Draw Player
        drawStickman(ctx, PLAYER);

        // --- Stop Camera/Viewport Scroll ---
        // Restore context so overlay (and future things) draw at screen coordinates
        ctx.restore();

        // Draw Win/Lose Screen overlay
        if (!isRunning && !hasWon) {
            drawOverlay("GAME OVER", "Press 'Play Again' to retry!", '#dc2626');
        } else if (hasWon) {
            drawOverlay("CHALLENGE COMPLETE!", "You mastered the long Obby!", '#16a34a');
        }
    }

    function drawOverlay(title, subtitle, color) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

        ctx.textAlign = 'center';
        ctx.shadowBlur = 0;

        // Title
        ctx.font = 'bold 48px Inter, sans-serif';
        ctx.fillStyle = color;
        ctx.fillText(title, VIEWPORT_WIDTH / 2, VIEWPORT_HEIGHT / 2 - 30);

        // Subtitle
        ctx.font = '20px Inter, sans-serif';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(subtitle, VIEWPORT_WIDTH / 2, VIEWPORT_HEIGHT / 2 + 10);
    }

    // --- Game States and Events ---

    function gameOver(msg) {
        isRunning = false;
        messageElement.textContent = msg;
        messageElement.classList.remove('text-green-700', 'text-yellow-600');
        messageElement.classList.add('text-red-600');
        resetButton.disabled = false;
        cancelAnimationFrame(animationFrameId);
    }

    function winGame() {
        isRunning = false;
        hasWon = true;
        messageElement.textContent = "You reached the GOAL! Obby Completed!";
        messageElement.classList.remove('text-green-700', 'text-red-600');
        messageElement.classList.add('text-yellow-600');
        resetButton.disabled = false;
        cancelAnimationFrame(animationFrameId);
    }

    function gameLoop() {
        if (!isRunning && !hasWon) return;

        updateGame();
        drawGame();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners and Setup ---

    function handleKeyDown(event) {
        if (!isRunning) return;
        switch (event.key) {
            case 'ArrowLeft':
            case 'a':
                KEYS.left = true;
                break;
            case 'ArrowRight':
            case 'd':
                KEYS.right = true;
                break;
            case 'ArrowUp':
            case 'w':
            case ' ': // Spacebar
                KEYS.jump = true;
                break;
        }
    }

    function handleKeyUp(event) {
        switch (event.key) {
            case 'ArrowLeft':
            case 'a':
                KEYS.left = false;
                break;
            case 'ArrowRight':
            case 'd':
                KEYS.right = false;
                break;
            case 'ArrowUp':
            case 'w':
            case ' ': // Spacebar
                KEYS.jump = false;
                break;
        }
    }

    function setupEventListeners() {
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        resetButton.addEventListener('click', resetGame);

        // Mobile/Touch Controls
        document.getElementById('mobileLeft').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.left = true; });
        document.getElementById('mobileLeft').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.left = false; });
        document.getElementById('mobileRight').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.right = true; });
        document.getElementById('mobileRight').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.right = false; });
        document.getElementById('mobileJump').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.jump = true; });
        document.getElementById('mobileJump').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.jump = false; });
    }

    // Initialize Game
    window.onload = function() {
        setupEventListeners();
        resetGame(); // Starts the first game loop
    };

</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Obby: The Long Run</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0fdf4;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            background-color: #ffffff;
            border: 8px solid #365314;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 16px;
            max-width: 800px; /* Max display width */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background-color: #e0f2fe;
            border: 4px solid #365314;
            border-radius: 8px;
            touch-action: manipulation;
        }
        .controls, .status {
            margin-top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .control-button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 700;
            background-color: #65a30d;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 0 #4d7c0f;
            transition: background-color 0.1s, box-shadow 0.1s, transform 0.1s;
        }
        .control-button:active {
            background-color: #4d7c0f;
            box-shadow: 0 0 0 #4d7c0f;
            transform: translateY(4px);
        }
        .control-button:disabled {
            background-color: #9ca3af;
            box-shadow: none;
            transform: translateY(0);
            cursor: not-allowed;
        }
        @media (max-width: 600px) {
            .controls {
                justify-content: space-around;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <h1 class="text-3xl font-bold text-center text-green-800 mb-4">Stickman Obby: The Long Run Challenge</h1>
    <canvas id="gameCanvas" width="700" height="450"></canvas>

    <div class="status mt-4 w-full">
        <p id="message" class="text-lg font-semibold text-green-700">Use A/D or Left/Right Arrows to move, Space/W/Up Arrow to jump!</p>
    </div>

    <div class="controls mt-4">
        <button id="resetButton" class="control-button w-full" disabled>Play Again</button>
    </div>

    <!-- Mobile Controls for touch -->
    <div class="controls mt-4 sm:hidden justify-center space-x-4">
        <button id="mobileLeft" class="control-button px-6 py-3">◀️ Left</button>
        <button id="mobileJump" class="control-button px-6 py-3">⬆️ Jump</button>
        <button id="mobileRight" class="control-button px-6 py-3">▶️ Right</button>
    </div>
</div>

<script>
    // --- Global Variables and Constants ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageElement = document.getElementById('message');
    const resetButton = document.getElementById('resetButton');

    // Display size (fixed size for viewport)
    const VIEWPORT_WIDTH = 700;
    const VIEWPORT_HEIGHT = 450;
    canvas.width = VIEWPORT_WIDTH;
    canvas.height = VIEWPORT_HEIGHT;

    // The entire game world size (much longer)
    const WORLD_WIDTH = 3000;
    const WORLD_HEIGHT = 450;

    // Game Physics Constants
    const GRAVITY = 0.6;
    const JUMP_FORCE = -13;
    const SPEED = 5;

    // Game State
    let isRunning = true;
    let hasWon = false;
    let animationFrameId;
    let cameraX = 0; // The camera offset for scrolling

    // Player Object
    let PLAYER = {
        x: 50,
        y: WORLD_HEIGHT - 60,
        width: 20,
        height: 40,
        velocityX: 0,
        velocityY: 0,
        onGround: false,
        isJumping: false,
        color: '#1e3a8a'
    };

    // Input Tracking
    const KEYS = { left: false, right: false, jump: false };

    // Platform Types
    const PLATFORM_TYPE = {
        NORMAL: 'normal',
        HAZARD: 'hazard',
        MOVING: 'moving', // New type
        GOAL: 'goal'
    };

    // Level Definition (The Extended Obby!)
    // Note: 'startX', 'endX', and 'speed' are used only for MOVING platforms.
    const LEVEL = [
        // Start Zone
        { x: 0, y: WORLD_HEIGHT - 20, w: 200, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Gap 1 & High Jump
        { x: 250, y: WORLD_HEIGHT - 80, w: 100, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        
        // Hazard 1: Lava Pit
        { x: 380, y: WORLD_HEIGHT - 20, w: 150, h: 20, type: PLATFORM_TYPE.HAZARD, color: '#ef4444' },

        // Steep Ascent 
        { x: 550, y: WORLD_HEIGHT - 120, w: 50, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        { x: 650, y: WORLD_HEIGHT - 200, w: 50, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // **SECTION 2: Moving Platforms**
        // Gap 3
        { x: 800, y: WORLD_HEIGHT - 250, w: 80, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Moving Platform 1 (Horizontal)
        { x: 950, y: WORLD_HEIGHT - 200, w: 120, h: 20, type: PLATFORM_TYPE.MOVING, color: '#fb923c', startX: 900, endX: 1200, speed: 2, currentDir: 1 },

        // Drop down to Ground
        { x: 1300, y: WORLD_HEIGHT - 100, w: 150, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Hazard 2: Long Spike Crawl
        { x: 1500, y: WORLD_HEIGHT - 20, w: 300, h: 20, type: PLATFORM_TYPE.HAZARD, color: '#ef4444' },

        // **SECTION 3: Vertical Challenge**
        // Staircase to high elevation
        { x: 1900, y: WORLD_HEIGHT - 80, w: 60, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        { x: 2000, y: WORLD_HEIGHT - 160, w: 60, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        { x: 2100, y: WORLD_HEIGHT - 240, w: 60, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Moving Platform 2 (Vertical - for a tricky jump)
        { x: 2300, y: WORLD_HEIGHT - 300, w: 50, h: 20, type: PLATFORM_TYPE.MOVING, color: '#fb923c', startY: WORLD_HEIGHT - 350, endY: WORLD_HEIGHT - 150, speed: 1.5, currentDir: 1, isVertical: true },

        // Final Hazard Skip
        { x: 2500, y: WORLD_HEIGHT - 20, w: 100, h: 20, type: PLATFORM_TYPE.HAZARD, color: '#ef4444' },

        // Final Goal Platform
        { x: WORLD_WIDTH - 200, y: WORLD_HEIGHT - 180, w: 200, h: 20, type: PLATFORM_TYPE.GOAL, color: '#facc15' },
    ];


    // --- Game Logic Functions ---

    function resetGame() {
        PLAYER.x = 50;
        PLAYER.y = WORLD_HEIGHT - 60;
        PLAYER.velocityX = 0;
        PLAYER.velocityY = 0;
        PLAYER.onGround = false;
        PLAYER.isJumping = false;
        cameraX = 0; // Reset camera

        isRunning = true;
        hasWon = false;
        messageElement.textContent = "Use A/D or Left/Right Arrows to move, Space/W/Up Arrow to jump!";
        messageElement.classList.remove('text-red-600', 'text-yellow-600');
        messageElement.classList.add('text-green-700');
        resetButton.disabled = true;

        // Reset moving platforms to their starting positions
        LEVEL.forEach(p => {
            if (p.type === PLATFORM_TYPE.MOVING) {
                p.x = p.startX || p.x;
                p.y = p.startY || p.y;
                p.currentDir = 1; // Start moving in positive direction
            }
        });

        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        gameLoop();
    }

    function checkCollision(objA, objB) {
        return objA.x < objB.x + objB.w &&
               objA.x + objA.width > objB.x &&
               objA.y < objB.y + objB.h &&
               objA.y + objA.height > objB.y;
    }

    function updateMovingPlatforms() {
        for (const platform of LEVEL) {
            if (platform.type === PLATFORM_TYPE.MOVING) {
                if (platform.isVertical) {
                    // Vertical Movement Logic
                    platform.y += platform.speed * platform.currentDir;

                    if (platform.currentDir === 1 && platform.y >= platform.endY) {
                        platform.currentDir = -1; // Reverse direction
                        platform.y = platform.endY;
                    } else if (platform.currentDir === -1 && platform.y <= platform.startY) {
                        platform.currentDir = 1; // Reverse direction
                        platform.y = platform.startY;
                    }
                } else {
                    // Horizontal Movement Logic
                    platform.x += platform.speed * platform.currentDir;

                    if (platform.currentDir === 1 && platform.x + platform.w >= platform.endX) {
                        platform.currentDir = -1; // Reverse direction
                        platform.x = platform.endX - platform.w;
                    } else if (platform.currentDir === -1 && platform.x <= platform.startX) {
                        platform.currentDir = 1; // Reverse direction
                        platform.x = platform.startX;
                    }
                }
            }
        }
    }

    function updateGame() {
        if (!isRunning || hasWon) return;

        // Update Moving Platforms before player movement
        updateMovingPlatforms();

        // 1. Handle Input & Gravity
        PLAYER.velocityX = 0;
        if (KEYS.left) { PLAYER.velocityX = -SPEED; }
        if (KEYS.right) { PLAYER.velocityX = SPEED; }
        PLAYER.velocityY += GRAVITY;

        // 2. Handle Jumping
        if (KEYS.jump && PLAYER.onGround && !PLAYER.isJumping) {
            PLAYER.velocityY = JUMP_FORCE;
            PLAYER.onGround = false;
            PLAYER.isJumping = true;
            // Short timeout to prevent immediate multiple jumps
            setTimeout(() => PLAYER.isJumping = false, 100);
        } else if (!KEYS.jump) {
            PLAYER.isJumping = false;
        }

        // 3. Update Position (Tentative move)
        PLAYER.x += PLAYER.velocityX;
        PLAYER.y += PLAYER.velocityY;

        // 4. Collision Detection and Response
        PLAYER.onGround = false;

        for (const platform of LEVEL) {
            const playerBox = { x: PLAYER.x, y: PLAYER.y, width: PLAYER.width, height: PLAYER.height };

            if (checkCollision(playerBox, platform)) {
                // HAZARD/GOAL CHECK
                if (platform.type === PLATFORM_TYPE.HAZARD) {
                    gameOver("You melted in the lava! Game Over.");
                    return;
                }
                if (platform.type === PLATFORM_TYPE.GOAL) {
                    winGame();
                    return;
                }

                // NORMAL & MOVING PLATFORM COLLISION (LANDING ONLY)
                const previousY = PLAYER.y - PLAYER.velocityY;
                const previousBottom = previousY + PLAYER.height;

                if (previousBottom <= platform.y && PLAYER.velocityY >= 0) {
                    PLAYER.y = platform.y - PLAYER.height; // Snap to the top
                    PLAYER.velocityY = 0; // Stop vertical movement
                    PLAYER.onGround = true;

                    // Carry the player with the moving platform
                    if (platform.type === PLATFORM_TYPE.MOVING) {
                        if (platform.isVertical) {
                            // Player stands still relative to X on vertical platforms
                            // (No horizontal shift from the platform itself)
                        } else {
                            // Apply platform's horizontal velocity to the player
                            PLAYER.x += platform.speed * platform.currentDir;
                        }
                    }
                }
            }
        }

        // 5. World Boundaries Check & Camera Update
        if (PLAYER.x < 0) {
            PLAYER.x = 0;
        }
        if (PLAYER.x + PLAYER.width > WORLD_WIDTH) {
            PLAYER.x = WORLD_WIDTH - PLAYER.width;
        }
        
        // Update Camera (Center the camera on the player, but clamp to world edges)
        cameraX = PLAYER.x - VIEWPORT_WIDTH / 2;
        cameraX = Math.max(0, cameraX); // Cannot scroll past the left edge
        cameraX = Math.min(WORLD_WIDTH - VIEWPORT_WIDTH, cameraX); // Cannot scroll past the right edge


        // 6. Fall Off World Check (Game Over)
        if (PLAYER.y > WORLD_HEIGHT) {
            gameOver("You fell into the abyss! Game Over.");
        }
    }

    // --- Drawing Functions ---

    function drawStickman(ctx, player) {
        const cx = player.x + player.width / 2; // Center X
        const headRadius = 8;
        const bodyY = player.y + headRadius * 2;
        const bodyHeight = player.height - headRadius * 2 - 5;

        ctx.strokeStyle = player.color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';

        // Head
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(cx, player.y + headRadius, headRadius, 0, Math.PI * 2);
        ctx.fill();

        // Body
        ctx.beginPath();
        ctx.moveTo(cx, bodyY);
        ctx.lineTo(cx, bodyY + bodyHeight);
        ctx.stroke();

        // Arms
        ctx.beginPath();
        ctx.moveTo(cx - 5, bodyY + 10);
        ctx.lineTo(cx + 5, bodyY + 10);
        ctx.stroke();

        // Legs
        const footY = player.y + player.height;
        ctx.beginPath();
        ctx.moveTo(cx, bodyY + bodyHeight);
        ctx.lineTo(cx - 5, footY);
        ctx.moveTo(cx, bodyY + bodyHeight);
        ctx.lineTo(cx + 5, footY);
        ctx.stroke();
    }

    function drawPlatform(ctx, p) {
        ctx.beginPath();
        ctx.rect(p.x, p.y, p.w, p.h);

        // Styling based on type
        if (p.type === PLATFORM_TYPE.HAZARD) {
            ctx.fillStyle = '#f87171'; // Red/Lava
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 10;
        } else if (p.type === PLATFORM_TYPE.GOAL) {
            ctx.fillStyle = '#fcd34d'; // Gold/Goal
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 10;
        } else if (p.type === PLATFORM_TYPE.MOVING) {
             ctx.fillStyle = '#fb923c'; // Orange/Moving
             ctx.shadowColor = '#f97316';
             ctx.shadowBlur = 8;
        }
        else {
            ctx.fillStyle = p.color;
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }
        ctx.fill();

        // Draw detail for hazards (spikes)
        if (p.type === PLATFORM_TYPE.HAZARD) {
            ctx.fillStyle = '#a1a1aa'; // Gray spikes
            const spikeSize = 8;
            for (let i = 0; i < p.w / spikeSize; i++) {
                ctx.beginPath();
                ctx.moveTo(p.x + i * spikeSize, p.y);
                ctx.lineTo(p.x + i * spikeSize + spikeSize / 2, p.y - spikeSize);
                ctx.lineTo(p.x + (i + 1) * spikeSize, p.y);
                ctx.fill();
            }
        }
    }

    function drawGame() {
        // Clear canvas and draw sky background
        ctx.clearRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
        ctx.fillStyle = '#e0f2fe';
        ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

        // --- Start Camera/Viewport Scroll ---
        // All subsequent draw commands will be offset by -cameraX
        ctx.save();
        ctx.translate(-cameraX, 0);

        // Draw Platforms
        LEVEL.forEach(p => drawPlatform(ctx, p));

        // Draw Player
        drawStickman(ctx, PLAYER);

        // --- Stop Camera/Viewport Scroll ---
        // Restore context so overlay (and future things) draw at screen coordinates
        ctx.restore();

        // Draw Win/Lose Screen overlay
        if (!isRunning && !hasWon) {
            drawOverlay("GAME OVER", "Press 'Play Again' to retry!", '#dc2626');
        } else if (hasWon) {
            drawOverlay("CHALLENGE COMPLETE!", "You mastered the long Obby!", '#16a34a');
        }
    }

    function drawOverlay(title, subtitle, color) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

        ctx.textAlign = 'center';
        ctx.shadowBlur = 0;

        // Title
        ctx.font = 'bold 48px Inter, sans-serif';
        ctx.fillStyle = color;
        ctx.fillText(title, VIEWPORT_WIDTH / 2, VIEWPORT_HEIGHT / 2 - 30);

        // Subtitle
        ctx.font = '20px Inter, sans-serif';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(subtitle, VIEWPORT_WIDTH / 2, VIEWPORT_HEIGHT / 2 + 10);
    }

    // --- Game States and Events ---

    function gameOver(msg) {
        isRunning = false;
        messageElement.textContent = msg;
        messageElement.classList.remove('text-green-700', 'text-yellow-600');
        messageElement.classList.add('text-red-600');
        resetButton.disabled = false;
        cancelAnimationFrame(animationFrameId);
    }

    function winGame() {
        isRunning = false;
        hasWon = true;
        messageElement.textContent = "You reached the GOAL! Obby Completed!";
        messageElement.classList.remove('text-green-700', 'text-red-600');
        messageElement.classList.add('text-yellow-600');
        resetButton.disabled = false;
        cancelAnimationFrame(animationFrameId);
    }

    function gameLoop() {
        if (!isRunning && !hasWon) return;

        updateGame();
        drawGame();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners and Setup ---

    function handleKeyDown(event) {
        if (!isRunning) return;
        switch (event.key) {
            case 'ArrowLeft':
            case 'a':
                KEYS.left = true;
                break;
            case 'ArrowRight':
            case 'd':
                KEYS.right = true;
                break;
            case 'ArrowUp':
            case 'w':
            case ' ': // Spacebar
                KEYS.jump = true;
                break;
        }
    }

    function handleKeyUp(event) {
        switch (event.key) {
            case 'ArrowLeft':
            case 'a':
                KEYS.left = false;
                break;
            case 'ArrowRight':
            case 'd':
                KEYS.right = false;
                break;
            case 'ArrowUp':
            case 'w':
            case ' ': // Spacebar
                KEYS.jump = false;
                break;
        }
    }

    function setupEventListeners() {
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        resetButton.addEventListener('click', resetGame);

        // Mobile/Touch Controls
        document.getElementById('mobileLeft').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.left = true; });
        document.getElementById('mobileLeft').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.left = false; });
        document.getElementById('mobileRight').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.right = true; });
        document.getElementById('mobileRight').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.right = false; });
        document.getElementById('mobileJump').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.jump = true; });
        document.getElementById('mobileJump').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.jump = false; });
    }

    // Initialize Game
    window.onload = function() {
        setupEventListeners();
        resetGame(); // Starts the first game loop
    };

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Obby: Checkpoint Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0fdf4;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            background-color: #ffffff;
            border: 8px solid #365314;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 16px;
            max-width: 800px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background-color: #e0f2fe;
            border: 4px solid #365314;
            border-radius: 8px;
            touch-action: manipulation;
        }
        .controls, .status {
            margin-top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        .status-item {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 700;
        }
        .lives {
            background-color: #fef08a; /* Yellow for Lives */
            color: #b45309;
        }
        .control-button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 700;
            background-color: #65a30d;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 0 #4d7c0f;
            transition: background-color 0.1s, box-shadow 0.1s, transform 0.1s;
        }
        .control-button:active {
            background-color: #4d7c0f;
            box-shadow: 0 0 0 #4d7c0f;
            transform: translateY(4px);
        }
        .control-button:disabled {
            background-color: #9ca3af;
            box-shadow: none;
            transform: translateY(0);
            cursor: not-allowed;
        }
        @media (max-width: 600px) {
            .controls-mobile {
                justify-content: space-around;
            }
            .status {
                justify-content: space-around;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <h1 class="text-3xl font-bold text-center text-green-800 mb-4">Stickman Obby: Checkpoint Challenge</h1>
    <canvas id="gameCanvas" width="700" height="450"></canvas>

    <div class="status w-full">
        <p id="message" class="text-lg font-semibold text-green-700">Go for the blue flags to save your progress!</p>
        <div id="lives-counter" class="status-item lives">Lives: 3</div>
    </div>

    <div class="controls mt-4">
        <button id="resetButton" class="control-button w-full" disabled>Start New Game</button>
    </div>

    <!-- Mobile Controls for touch -->
    <div class="controls controls-mobile mt-4 sm:hidden justify-center space-x-4">
        <button id="mobileLeft" class="control-button px-6 py-3">◀️ Left</button>
        <button id="mobileJump" class="control-button px-6 py-3">⬆️ Jump</button>
        <button id="mobileRight" class="control-button px-6 py-3">▶️ Right</button>
    </div>
</div>

<script>
    // --- Global Variables and Constants ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageElement = document.getElementById('message');
    const resetButton = document.getElementById('resetButton');
    const livesCounterElement = document.getElementById('lives-counter');

    // Display size (fixed size for viewport)
    const VIEWPORT_WIDTH = 700;
    const VIEWPORT_HEIGHT = 450;
    canvas.width = VIEWPORT_WIDTH;
    canvas.height = VIEWPORT_HEIGHT;

    // The entire game world size (extended)
    const WORLD_WIDTH = 3500;
    const WORLD_HEIGHT = 450;

    // Game Physics Constants
    const GRAVITY = 0.6;
    const JUMP_FORCE = -13;
    const SPEED = 3.5; // Adjusted speed!

    // Game State
    let isRunning = true;
    let hasWon = false;
    let animationFrameId;
    let cameraX = 0;
    
    let LIVES = 3;
    const INITIAL_LIVES = 3;
    let CURRENT_CHECKPOINT = { x: 50, y: WORLD_HEIGHT - 60 }; // Start position

    // Player Object
    let PLAYER = {
        x: CURRENT_CHECKPOINT.x,
        y: CURRENT_CHECKPOINT.y,
        width: 20,
        height: 40,
        velocityX: 0,
        velocityY: 0,
        onGround: false,
        isJumping: false,
        color: '#1e3a8a'
    };

    // Input Tracking
    const KEYS = { left: false, right: false, jump: false };

    // Platform Types
    const PLATFORM_TYPE = {
        NORMAL: 'normal',
        HAZARD: 'hazard',
        MOVING: 'moving',
        CHECKPOINT: 'checkpoint', // New type
        GOAL: 'goal'
    };

    // Level Definition (Extended with Checkpoints and difficulty ramp)
    // Note: 'startX', 'endX', 'startY', 'endY', and 'speed' are used only for MOVING platforms.
    const LEVEL = [
        // Start Zone
        { x: 0, y: WORLD_HEIGHT - 20, w: 250, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80', reached: true },
        
        // Easy Jumps
        { x: 300, y: WORLD_HEIGHT - 80, w: 100, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        { x: 450, y: WORLD_HEIGHT - 120, w: 50, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },

        // Hazard 1: Small Lava Pit
        { x: 550, y: WORLD_HEIGHT - 20, w: 120, h: 20, type: PLATFORM_TYPE.HAZARD, color: '#ef4444' },

        // --- CHECKPOINT 1 ---
        { x: 750, y: WORLD_HEIGHT - 100, w: 150, h: 20, type: PLATFORM_TYPE.CHECKPOINT, color: '#3b82f6', isFlag: true, reached: false },

        // **SECTION 2: Moving Platform Challenge** (Increased Difficulty)
        
        // Moving Platform 1 (Horizontal, faster)
        { x: 1000, y: WORLD_HEIGHT - 200, w: 100, h: 20, type: PLATFORM_TYPE.MOVING, color: '#fb923c', startX: 950, endX: 1300, speed: 3, currentDir: 1 },

        // Small stationary platform
        { x: 1400, y: WORLD_HEIGHT - 200, w: 50, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        
        // Hazard 2: Long Gap over abyss
        
        // Moving Platform 2 (Vertical, fast)
        { x: 1650, y: WORLD_HEIGHT - 350, w: 60, h: 20, type: PLATFORM_TYPE.MOVING, color: '#fb923c', startY: WORLD_HEIGHT - 400, endY: WORLD_HEIGHT - 150, speed: 2, currentDir: 1, isVertical: true },

        // --- CHECKPOINT 2 ---
        { x: 1900, y: WORLD_HEIGHT - 120, w: 150, h: 20, type: PLATFORM_TYPE.CHECKPOINT, color: '#3b82f6', isFlag: true, reached: false },

        // **SECTION 3: Precision Jumps and High Hazard** (Highest Difficulty)
        
        // Floating platform chain
        { x: 2150, y: WORLD_HEIGHT - 180, w: 50, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        { x: 2300, y: WORLD_HEIGHT - 250, w: 50, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        
        // High, tricky horizontal platform over lava
        { x: 2450, y: WORLD_HEIGHT - 100, w: 200, h: 20, type: PLATFORM_TYPE.HAZARD, color: '#ef4444' },
        
        // Moving Platform 3 (Combining horizontal and vertical movement for maximum difficulty - must be timed perfectly)
        { x: 2800, y: WORLD_HEIGHT - 250, w: 80, h: 20, type: PLATFORM_TYPE.MOVING, color: '#fb923c', startX: 2750, endX: 2950, startY: WORLD_HEIGHT - 300, endY: WORLD_HEIGHT - 100, speed: 1.5, currentDir: 1, isVertical: false, movePhase: 0 },

        // Final safe spot before goal
        { x: 3100, y: WORLD_HEIGHT - 180, w: 80, h: 20, type: PLATFORM_TYPE.NORMAL, color: '#4ade80' },
        
        // Final Goal Platform
        { x: WORLD_WIDTH - 200, y: WORLD_HEIGHT - 180, w: 200, h: 20, type: PLATFORM_TYPE.GOAL, color: '#facc15' },
    ];


    // --- Game Logic Functions ---

    function resetPlayerPosition() {
        PLAYER.x = CURRENT_CHECKPOINT.x;
        PLAYER.y = CURRENT_CHECKPOINT.y;
        PLAYER.velocityX = 0;
        PLAYER.velocityY = 0;
        PLAYER.onGround = false;
        PLAYER.isJumping = false;

        // Force camera to immediately follow the new checkpoint position
        cameraX = PLAYER.x - VIEWPORT_WIDTH / 2;
        cameraX = Math.max(0, cameraX);
        cameraX = Math.min(WORLD_WIDTH - VIEWPORT_WIDTH, cameraX);
    }

    function resetGame(fullReset = true) {
        if (fullReset) {
            LIVES = INITIAL_LIVES;
            CURRENT_CHECKPOINT = { x: 50, y: WORLD_HEIGHT - 60 }; // Reset start position
            
            // Reset all checkpoint flags and moving platforms
            LEVEL.forEach(p => {
                if (p.isFlag) p.reached = false;
                if (p.type === PLATFORM_TYPE.MOVING) {
                    p.x = p.startX || p.x;
                    p.y = p.startY || p.y;
                    p.currentDir = 1;
                    p.movePhase = 0; // Reset combined movement phase
                }
            });
        }
        
        resetPlayerPosition();
        
        isRunning = true;
        hasWon = false;
        messageElement.textContent = "Go for the blue flags to save your progress!";
        messageElement.classList.remove('text-red-600', 'text-yellow-600');
        messageElement.classList.add('text-green-700');
        resetButton.disabled = fullReset ? true : false;
        livesCounterElement.textContent = `Lives: ${LIVES}`;


        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        gameLoop();
    }

    function checkCollision(objA, objB) {
        return objA.x < objB.x + objB.w &&
               objA.x + objA.width > objB.x &&
               objA.y < objB.y + objB.h &&
               objA.y + objA.height > objB.y;
    }

    function updateMovingPlatforms() {
        for (const platform of LEVEL) {
            if (platform.type === PLATFORM_TYPE.MOVING) {
                if (platform.isVertical) {
                    // Vertical Movement
                    platform.y += platform.speed * platform.currentDir;
                    if (platform.currentDir === 1 && platform.y >= platform.endY) {
                        platform.currentDir = -1;
                        platform.y = platform.endY;
                    } else if (platform.currentDir === -1 && platform.y <= platform.startY) {
                        platform.currentDir = 1;
                        platform.y = platform.startY;
                    }
                } else if (platform.startY !== undefined) {
                    // Combined Horizontal/Vertical (for platform 3)
                    platform.movePhase += platform.speed / 50; // Use a smoother phase speed

                    // Horizontal sinusoidal movement
                    platform.x = platform.startX + Math.sin(platform.movePhase) * ((platform.endX - platform.startX) / 2);
                    
                    // Vertical sinusoidal movement
                    platform.y = platform.startY + Math.cos(platform.movePhase * 0.5) * ((platform.endY - platform.startY) / 2);
                    
                } else {
                    // Horizontal Movement
                    platform.x += platform.speed * platform.currentDir;
                    if (platform.currentDir === 1 && platform.x + platform.w >= platform.endX) {
                        platform.currentDir = -1;
                        platform.x = platform.endX - platform.w;
                    } else if (platform.currentDir === -1 && platform.x <= platform.startX) {
                        platform.currentDir = 1;
                        platform.x = platform.startX;
                    }
                }
            }
        }
    }

    function updateGame() {
        if (!isRunning || hasWon) return;

        updateMovingPlatforms();

        // 1. Handle Input & Gravity
        PLAYER.velocityX = 0;
        if (KEYS.left) { PLAYER.velocityX = -SPEED; }
        if (KEYS.right) { PLAYER.velocityX = SPEED; }
        PLAYER.velocityY += GRAVITY;

        // 2. Handle Jumping
        if (KEYS.jump && PLAYER.onGround && !PLAYER.isJumping) {
            PLAYER.velocityY = JUMP_FORCE;
            PLAYER.onGround = false;
            PLAYER.isJumping = true;
            setTimeout(() => PLAYER.isJumping = false, 100);
        } else if (!KEYS.jump) {
            PLAYER.isJumping = false;
        }

        // 3. Update Position (Tentative move)
        PLAYER.x += PLAYER.velocityX;
        PLAYER.y += PLAYER.velocityY;

        // 4. Collision Detection and Response
        PLAYER.onGround = false;

        for (const platform of LEVEL) {
            const playerBox = { x: PLAYER.x, y: PLAYER.y, width: PLAYER.width, height: PLAYER.height };

            if (checkCollision(playerBox, platform)) {
                
                // HAZARD/GOAL CHECK
                if (platform.type === PLATFORM_TYPE.HAZARD) {
                    gameOver("Lava claimed you!", false); // Death without full reset
                    return;
                }
                if (platform.type === PLATFORM_TYPE.GOAL) {
                    winGame();
                    return;
                }
                
                // CHECKPOINT LOGIC
                if (platform.type === PLATFORM_TYPE.CHECKPOINT && !platform.reached) {
                    platform.reached = true;
                    // Set checkpoint slightly above the platform
                    CURRENT_CHECKPOINT = { x: platform.x + (platform.w / 2) - (PLAYER.width / 2), y: platform.y - PLAYER.height - 10 };
                    messageElement.textContent = "Checkpoint Reached! Progress Saved!";
                    messageElement.classList.remove('text-green-700');
                    messageElement.classList.add('text-blue-600');
                    // Briefly revert message color after a delay
                    setTimeout(() => messageElement.classList.remove('text-blue-600'), 1500);
                    setTimeout(() => messageElement.classList.add('text-green-700'), 1500);
                }

                // NORMAL & MOVING PLATFORM COLLISION (LANDING ONLY)
                const previousY = PLAYER.y - PLAYER.velocityY;
                const previousBottom = previousY + PLAYER.height;

                if (previousBottom <= platform.y && PLAYER.velocityY >= 0) {
                    PLAYER.y = platform.y - PLAYER.height; // Snap to the top
                    PLAYER.velocityY = 0; // Stop vertical movement
                    PLAYER.onGround = true;

                    // Carry the player with the moving platform
                    if (platform.type === PLATFORM_TYPE.MOVING) {
                        if (!platform.isVertical) {
                             // Apply platform's velocity (horizontal and/or sinusoidal X)
                            if (platform.startX !== undefined && platform.endX !== undefined && platform.startY === undefined) {
                                PLAYER.x += platform.speed * platform.currentDir;
                            } else if (platform.startY !== undefined) {
                                // For combined movement, approximate X shift based on movePhase derivative (simpler approach)
                                PLAYER.x += (platform.x - previousXForMovement); 
                            }
                        }
                    }
                }
            }
        }
        
        // Save current platform x before update for next frame's movement transfer calculation
        const previousXForMovement = PLAYER.x;
        
        // 5. World Boundaries Check & Camera Update
        if (PLAYER.x < 0) { PLAYER.x = 0; }
        if (PLAYER.x + PLAYER.width > WORLD_WIDTH) { PLAYER.x = WORLD_WIDTH - PLAYER.width; }
        
        // Camera Update
        cameraX = PLAYER.x - VIEWPORT_WIDTH / 2;
        cameraX = Math.max(0, cameraX);
        cameraX = Math.min(WORLD_WIDTH - VIEWPORT_WIDTH, cameraX);


        // 6. Fall Off World Check (Game Over)
        if (PLAYER.y > WORLD_HEIGHT) {
            gameOver("You fell into the abyss!", false); // Death without full reset
        }
    }

    // --- Drawing Functions ---

    function drawStickman(ctx, player) {
        const cx = player.x + player.width / 2;
        const headRadius = 8;
        const bodyY = player.y + headRadius * 2;
        const bodyHeight = player.height - headRadius * 2 - 5;

        ctx.strokeStyle = player.color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';

        // Head
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(cx, player.y + headRadius, headRadius, 0, Math.PI * 2);
        ctx.fill();

        // Body
        ctx.beginPath();
        ctx.moveTo(cx, bodyY);
        ctx.lineTo(cx, bodyY + bodyHeight);
        ctx.stroke();

        // Arms
        ctx.beginPath();
        ctx.moveTo(cx - 5, bodyY + 10);
        ctx.lineTo(cx + 5, bodyY + 10);
        ctx.stroke();

        // Legs
        const footY = player.y + player.height;
        ctx.beginPath();
        ctx.moveTo(cx, bodyY + bodyHeight);
        ctx.lineTo(cx - 5, footY);
        ctx.moveTo(cx, bodyY + bodyHeight);
        ctx.lineTo(cx + 5, footY);
        ctx.stroke();
    }

    function drawPlatform(ctx, p) {
        ctx.beginPath();
        ctx.rect(p.x, p.y, p.w, p.h);

        // Styling based on type
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';

        if (p.type === PLATFORM_TYPE.HAZARD) {
            ctx.fillStyle = '#f87171'; // Red/Lava
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 10;
        } else if (p.type === PLATFORM_TYPE.GOAL) {
            ctx.fillStyle = '#fcd34d'; // Gold/Goal
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 10;
        } else if (p.type === PLATFORM_TYPE.MOVING) {
             ctx.fillStyle = '#fb923c'; // Orange/Moving
             ctx.shadowColor = '#f97316';
             ctx.shadowBlur = 8;
        } else if (p.type === PLATFORM_TYPE.CHECKPOINT) {
             ctx.fillStyle = p.color; // Blue/Checkpoint
             if (p.reached) {
                 ctx.shadowColor = '#2563eb';
                 ctx.shadowBlur = 15;
                 // Draw the flag pole and flag
                 ctx.fillStyle = p.color;
                 ctx.fillRect(p.x + p.w / 2 - 2, p.y - 40, 4, 40); // Pole
                 
                 ctx.beginPath(); // Flag
                 ctx.moveTo(p.x + p.w / 2 + 2, p.y - 40);
                 ctx.lineTo(p.x + p.w / 2 + 2, p.y - 20);
                 ctx.lineTo(p.x + p.w / 2 + 20, p.y - 30);
                 ctx.closePath();
                 ctx.fill();
             }
        }
        else {
            ctx.fillStyle = p.color;
        }
        ctx.fill();

        // Draw detail for hazards (spikes)
        if (p.type === PLATFORM_TYPE.HAZARD) {
            ctx.fillStyle = '#a1a1aa';
            const spikeSize = 8;
            for (let i = 0; i < p.w / spikeSize; i++) {
                ctx.beginPath();
                ctx.moveTo(p.x + i * spikeSize, p.y);
                ctx.lineTo(p.x + i * spikeSize + spikeSize / 2, p.y - spikeSize);
                ctx.lineTo(p.x + (i + 1) * spikeSize, p.y);
                ctx.fill();
            }
        }
    }

    function drawGame() {
        // Clear canvas and draw sky background
        ctx.clearRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
        ctx.fillStyle = '#e0f2fe';
        ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

        // --- Start Camera/Viewport Scroll ---
        ctx.save();
        ctx.translate(-cameraX, 0);

        // Draw Platforms
        LEVEL.forEach(p => drawPlatform(ctx, p));

        // Draw Player
        drawStickman(ctx, PLAYER);

        // --- Stop Camera/Viewport Scroll ---
        ctx.restore();

        // Draw Win/Lose Screen overlay
        if (!isRunning && !hasWon) {
            drawOverlay("GAME OVER", "You ran out of lives!", '#dc2626');
            resetButton.textContent = "Start New Game";
        } else if (hasWon) {
            drawOverlay("CHALLENGE COMPLETE!", "You mastered the long Obby!", '#16a34a');
            resetButton.textContent = "Play Again";
        }
    }

    function drawOverlay(title, subtitle, color) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

        ctx.textAlign = 'center';
        ctx.shadowBlur = 0;

        // Title
        ctx.font = 'bold 48px Inter, sans-serif';
        ctx.fillStyle = color;
        ctx.fillText(title, VIEWPORT_WIDTH / 2, VIEWPORT_HEIGHT / 2 - 30);

        // Subtitle
        ctx.font = '20px Inter, sans-serif';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(subtitle, VIEWPORT_WIDTH / 2, VIEWPORT_HEIGHT / 2 + 10);
    }

    // --- Game States and Events ---

    function gameOver(msg, fullRestartNeeded) {
        if (fullRestartNeeded || LIVES <= 1) {
            // Hard Game Over
            LIVES = 0;
            isRunning = false;
            messageElement.textContent = `CRITICAL FAILURE: ${msg}`;
            messageElement.classList.remove('text-green-700', 'text-yellow-600', 'text-blue-600');
            messageElement.classList.add('text-red-600');
            resetButton.disabled = false;
            livesCounterElement.textContent = `Lives: ${LIVES}`;
            cancelAnimationFrame(animationFrameId);
        } else {
            // Soft Game Over (Respawn at Checkpoint)
            LIVES--;
            messageElement.textContent = `LOST A LIFE! ${msg} Respawning at last checkpoint.`;
            messageElement.classList.remove('text-green-700', 'text-yellow-600', 'text-blue-600');
            messageElement.classList.add('text-red-600');
            livesCounterElement.textContent = `Lives: ${LIVES}`;

            // Reset player and immediately restart loop
            resetPlayerPosition();
            
            // Briefly revert message color after a delay
            setTimeout(() => messageElement.classList.remove('text-red-600'), 1500);
            setTimeout(() => messageElement.classList.add('text-green-700'), 1500);
            // Ensure no interruption to the running game loop
        }
    }

    function winGame() {
        isRunning = false;
        hasWon = true;
        messageElement.textContent = "You reached the GOAL! Obby Completed!";
        messageElement.classList.remove('text-green-700', 'text-red-600', 'text-blue-600');
        messageElement.classList.add('text-yellow-600');
        resetButton.disabled = false;
        livesCounterElement.textContent = `Lives: ${LIVES}`;
        cancelAnimationFrame(animationFrameId);
    }

    function gameLoop() {
        if (!isRunning && !hasWon) return;

        updateGame();
        drawGame();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners and Setup ---

    function handleKeyDown(event) {
        if (!isRunning) return;
        switch (event.key) {
            case 'ArrowLeft': case 'a': KEYS.left = true; break;
            case 'ArrowRight': case 'd': KEYS.right = true; break;
            case 'ArrowUp': case 'w': case ' ': KEYS.jump = true; break;
        }
    }

    function handleKeyUp(event) {
        switch (event.key) {
            case 'ArrowLeft': case 'a': KEYS.left = false; break;
            case 'ArrowRight': case 'd': KEYS.right = false; break;
            case 'ArrowUp': case 'w': case ' ': KEYS.jump = false; break;
        }
    }

    function setupEventListeners() {
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        // Reset button now passes 'true' for a full reset
        resetButton.addEventListener('click', () => resetGame(true)); 

        // Mobile/Touch Controls
        document.getElementById('mobileLeft').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.left = true; });
        document.getElementById('mobileLeft').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.left = false; });
        document.getElementById('mobileRight').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.right = true; });
        document.getElementById('mobileRight').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.right = false; });
        document.getElementById('mobileJump').addEventListener('touchstart', (e) => { e.preventDefault(); KEYS.jump = true; });
        document.getElementById('mobileJump').addEventListener('touchend', (e) => { e.preventDefault(); KEYS.jump = false; });
    }

    // Initialize Game
    window.onload = function() {
        setupEventListeners();
        resetGame(true); // Start a new game
    };

</script>
</body>
</html>

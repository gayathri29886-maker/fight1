<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic AI Clash (Scrolling)</title>
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d0d;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }
        canvas {
            /* Stage background: subtle gradient for "realism" */
            background: linear-gradient(to bottom, #444444 0%, #1a1a1a 80%, #0d0d0d 100%);
            display: block;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            border-radius: 16px;
            border: 4px solid #333;
            max-width: 100%;
            height: auto;
        }

        /* Health Bar Styling */
        .health-bar-container {
            width: 100%;
            height: 35px;
            background: #555;
            border: 4px solid #222;
            border-radius: 8px;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .health-bar {
            height: 100%;
            transition: width 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            border-radius: 4px;
        }

        .game-container {
            width: 100%;
            max-width: 900px;
        }

        /* Fight Message Overlay */
        #displayText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            font-weight: 900;
            color: #ffdd57; /* Gold Yellow */
            text-shadow: 0 0 15px rgba(255, 204, 0, 1), 0 0 30px rgba(255, 100, 0, 0.7);
            pointer-events: none;
            z-index: 10;
            user-select: none;
        }

        /* Timer Styling */
        #timer {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(255, 255, 255, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(255, 255, 255, 0.4); }
        }
    </style>
</head>
<body>

    <div class="game-container flex flex-col items-center space-y-6">
        <h1 class="text-4xl font-extrabold text-white mb-4 uppercase tracking-widest">AI CLASH OF RECTS (SCROLLING)</h1>

        <!-- Health and Timer UI -->
        <div class="w-full flex justify-center items-center gap-6 p-4 bg-[#1a1a1a] rounded-xl shadow-2xl">
            
            <!-- Player 1 Health -->
            <div class="flex-1 space-y-1">
                <p class="text-sm font-bold text-red-400">PLAYER (YOU)</p>
                <div class="health-bar-container">
                    <div id="player1Health" class="health-bar bg-red-600" style="width: 100%;"></div>
                </div>
            </div>

            <!-- Timer -->
            <div id="timer" class="text-4xl font-black bg-gray-900 text-yellow-400 rounded-full h-16 w-16 flex items-center justify-center shadow-lg border-2 border-yellow-400">60</div>

            <!-- AI Health -->
            <div class="flex-1 space-y-1 text-right">
                <p class="text-sm font-bold text-blue-400">AI (CPU)</p>
                <div class="health-bar-container flex justify-end">
                    <div id="player2Health" class="health-bar bg-blue-600" style="width: 100%;"></div>
                </div>
            </div>
        </div>

        <!-- Game Canvas Area -->
        <div class="relative w-full aspect-[4/3] max-h-[675px]">
            <canvas id="gameCanvas" width="900" height="675"></canvas>
            <div id="displayText" class="hidden"></div>
        </div>

        <!-- Controls Hint -->
        <div class="w-full text-center text-sm p-4 bg-[#1a1a1a] rounded-xl shadow-lg border border-gray-700">
            <h3 class="font-bold text-lg mb-2 text-red-400">PLAYER CONTROLS:</h3>
            <p>
                Move: <span class="font-mono bg-gray-700 px-2 py-1 rounded-md shadow-inner">A</span> (Left), 
                <span class="font-mono bg-gray-700 px-2 py-1 rounded-md shadow-inner">D</span> (Right) 
                | Jump: <span class="font-mono bg-gray-700 px-2 py-1 rounded-md shadow-inner">W</span> 
                | **Attack:** <span class="font-mono bg-yellow-600 text-black px-2 py-1 rounded-md shadow-lg">Spacebar</span>
            </p>
        </div>
    </div>

    <script>
        // --- Setup and Constants ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const GRAVITY = 0.7;
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const FLOOR = CANVAS_HEIGHT - 90; // Ground position
        const AI_ATTACK_RANGE = 120;
        const AI_OPTIMAL_DISTANCE = 150;
        const STUN_DURATION = 300; // 300ms of stun

        // UI elements
        const timerEl = document.getElementById('timer');
        const player1HealthEl = document.getElementById('player1Health');
        const player2HealthEl = document.getElementById('player2Health');
        const displayTextEl = document.getElementById('displayText');

        // Game State
        let timer = 60;
        let isGameOver = false;
        let timerId;
        
        // Camera Object: Tracks how much the world is offset
        const camera = {
            offset: { x: 0, y: 0 },
            targetX: 0,
            smoothing: 0.08
        };
        
        // The game world width is much wider than the canvas (e.g., 2.5x the viewable area)
        const WORLD_WIDTH = CANVAS_WIDTH * 2.5; 
        const CAMERA_DEAD_ZONE = 100; // Area where the camera stops moving near edges

        // --- Utility Functions ---

        function decreaseTimer() {
            if (timer > 0) {
                timerId = setTimeout(decreaseTimer, 1000);
                timer--;
                timerEl.innerHTML = timer;
            }

            if (timer === 0) {
                determineWinner({ player1, player2 });
            }
        }

        function rectangularCollision({ rectangle1, rectangle2 }) {
            return (
                rectangle1.attackBox.position.x + rectangle1.attackBox.width >= rectangle2.position.x && 
                rectangle1.attackBox.position.x <= rectangle2.position.x + rectangle2.width && 
                rectangle1.attackBox.position.y + rectangle1.attackBox.height >= rectangle2.position.y && 
                rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height 
            );
        }

        function determineWinner({ player1, player2 }) {
            if (isGameOver) return; 
            isGameOver = true;
            displayTextEl.style.display = 'block';
            
            if (timerId) clearTimeout(timerId);

            if (player1.health === player2.health || (player1.health > 0 && player2.health > 0 && timer === 0)) {
                displayTextEl.innerHTML = 'TIME OUT! TIE!';
            } else if (player1.health > player2.health) {
                displayTextEl.innerHTML = 'PLAYER WINS!';
                displayTextEl.style.color = '#dc2626';
            } else if (player2.health > player1.health) {
                displayTextEl.innerHTML = 'AI WINS!';
                displayTextEl.style.color = '#2563eb';
            }
        }

        // --- Camera Logic ---
        function updateCamera(p1, p2) {
            // 1. Calculate the center point between the two fighters
            const centerPoint = (p1.position.x + p2.position.x) / 2;
            
            // 2. Determine the desired offset to center the fighters
            // We want the center point to be drawn at CANVAS_WIDTH / 2
            camera.targetX = centerPoint - CANVAS_WIDTH / 2;

            // 3. Clamp the camera offset to the boundaries of the world
            // The stage starts at 0 and ends at WORLD_WIDTH.
            // Max offset: WORLD_WIDTH - CANVAS_WIDTH
            // Min offset: 0
            
            const maxOffset = WORLD_WIDTH - CANVAS_WIDTH;
            camera.targetX = Math.max(0, Math.min(camera.targetX, maxOffset));


            // 4. Smoothly move the current camera offset towards the target
            camera.offset.x += (camera.targetX - camera.offset.x) * camera.smoothing;
        }
        
        // --- Fighter Class ---
        class Fighter {
            constructor({ position, velocity, color, isAI = false }) {
                this.position = position;
                this.velocity = velocity;
                this.width = 50;
                this.height = 150;
                this.color = color;
                this.health = 100;
                this.isAttacking = false;
                this.attackCooldown = false;
                this.isAI = isAI;
                this.isStunned = false; // NEW: Stun state
                this.attackBox = {
                    position: { x: this.position.x, y: this.position.y },
                    width: 100,
                    height: 50,
                };
            }

            draw() {
                // Draw fighter rectangle
                ctx.fillStyle = this.color;
                ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
                
                // Draw a simple head 
                ctx.fillStyle = 'white'; 
                ctx.fillRect(this.position.x + 5, this.position.y - 15, this.width - 10, 20);

                // Draw stun indicator if stunned
                if(this.isStunned) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                    ctx.fillText('STUN!', this.position.x, this.position.y - 40);
                }

                // Draw attack box (only if attacking)
                if (this.isAttacking) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; 
                    ctx.fillRect(
                        this.attackBox.position.x,
                        this.attackBox.position.y,
                        this.attackBox.width,
                        this.attackBox.height
                    );
                }
            }

            update() {
                this.draw();
                
                // Only update position if not stunned
                if (!this.isStunned) {
                    this.position.x += this.velocity.x;
                    this.position.y += this.velocity.y;
                }
                
                // Apply gravity always
                if (this.position.y + this.height + this.velocity.y < FLOOR) {
                    this.velocity.y += GRAVITY;
                } else {
                    this.velocity.y = 0;
                    this.position.y = FLOOR - this.height; // Snap to ground
                }

                // Horizontal boundary check against WORLD_WIDTH
                if (this.position.x < 0) {
                    this.position.x = 0;
                } else if (this.position.x + this.width > WORLD_WIDTH) {
                    this.position.x = WORLD_WIDTH - this.width;
                }

                // Update attack box position
                if (this.isAI) {
                    this.attackBox.position.x = this.position.x - this.attackBox.width + 10;
                } else {
                    this.attackBox.position.x = this.position.x + this.width - 10;
                }
                this.attackBox.position.y = this.position.y + 50; 
            }

            attack() {
                if (this.attackCooldown || this.isStunned) return;

                this.isAttacking = true;
                this.attackCooldown = true;

                setTimeout(() => {
                    this.isAttacking = false;
                }, 100);

                setTimeout(() => {
                    this.attackCooldown = false;
                }, 500); 
            }

            takeHit() {
                if (this.isStunned) return; // Cannot be hit while stunned (prevents infinite loop)

                this.health -= 15;
                if (this.health < 0) this.health = 0;

                // NEW: Set stun state and prevent movement
                this.isStunned = true;
                this.velocity.x = 0; // Immediately stop horizontal movement
                setTimeout(() => {
                    this.isStunned = false;
                }, STUN_DURATION);


                // Update health bar UI
                if (this.isAI) {
                    player2HealthEl.style.width = this.health + '%';
                } else {
                    player1HealthEl.style.width = this.health + '%';
                }
            }

            // --- AI Logic Method ---
            AI_move(target) {
                if (this.health <= 0 || this.isStunned) { 
                    this.velocity.x = 0; // Stop movement if defeated or stunned
                    return;
                }

                const distance = Math.abs(target.position.x - this.position.x);
                const direction = target.position.x < this.position.x ? -1 : 1;
                
                this.velocity.x = 0; // Stop movement by default

                // 1. Attack Decision
                if (distance <= AI_ATTACK_RANGE && !this.attackCooldown && this.velocity.y === 0) {
                    this.attack();
                    this.velocity.x = -direction * 1; 
                    return;
                }

                // 2. Movement Decision
                if (distance > AI_OPTIMAL_DISTANCE) {
                    this.velocity.x = direction * 3; 
                } else if (distance < AI_ATTACK_RANGE - 50) {
                    this.velocity.x = -direction * 1;
                }

                // 3. Dodge/Jump Decision 
                if (this.velocity.y === 0 && Math.random() < 0.01) {
                    this.velocity.y = -18; 
                }

                // 4. Defensive Jump if player is attacking
                if (target.isAttacking && this.velocity.y === 0) {
                    this.velocity.y = -22; 
                }
            }
        }

        // --- Initialize Fighters ---
        // Placing them farther apart for the scrolling effect to be immediately visible
        const player1 = new Fighter({
            position: { x: 300, y: 0 },
            velocity: { x: 0, y: 0 },
            color: '#dc2626', 
            isAI: false
        });

        const player2 = new Fighter({
            position: { x: 600, y: 100 },
            velocity: { x: 0, y: 0 },
            color: '#2563eb', 
            isAI: true 
        });

        // --- Input Handling ---
        const keys = {
            a: { pressed: false },
            d: { pressed: false },
        };

        window.addEventListener('keydown', (event) => {
            if (isGameOver || player1.isStunned) return;

            switch (event.key) {
                // Player Keys
                case 'a':
                case 'A':
                    keys.a.pressed = true;
                    break;
                case 'd':
                case 'D':
                    keys.d.pressed = true;
                    break;
                case 'w':
                case 'W':
                    if (player1.velocity.y === 0) player1.velocity.y = -20; // Jump force
                    break;
                case ' ':
                    event.preventDefault(); 
                    player1.attack();
                    break;
            }
        });

        window.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'a':
                case 'A':
                    keys.a.pressed = false;
                    break;
                case 'd':
                case 'D':
                    keys.d.pressed = false;
                    break;
            }
        });

        // Function to draw the scrolling background elements
        function drawBackground() {
            // Draw a series of fixed "pillars" to show the scrolling effect
            const pillarCount = Math.floor(WORLD_WIDTH / 100); 
            ctx.fillStyle = '#111';
            for (let i = 0; i < pillarCount; i++) {
                // Draw a tall, dark pillar
                ctx.fillRect(i * 150 + 50, CANVAS_HEIGHT - 350, 10, 260);
            }
        }

        // --- Game Loop (Animation) ---
        function animate() {
            window.requestAnimationFrame(animate);
            if (isGameOver) return; 

            // 1. Calculate and Update Camera Position
            updateCamera(player1, player2);

            // 2. Clear the canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // 3. Apply Camera Translation
            ctx.save();
            ctx.translate(-camera.offset.x, 0); // Shift the entire drawing surface

            // 4. Draw Background and Ground
            drawBackground();
            ctx.fillStyle = '#0d0d0d';
            ctx.fillRect(0, FLOOR, WORLD_WIDTH, CANVAS_HEIGHT - FLOOR); // Draw ground across the whole world

            // 5. AI Logic
            player2.AI_move(player1);

            // 6. Player Input (Only if not stunned)
            player1.velocity.x = 0;
            if (!player1.isStunned) {
                if (keys.a.pressed) player1.velocity.x = -5;
                if (keys.d.pressed) player1.velocity.x = 5;
            }

            // 7. Update Fighters
            player1.update();
            player2.update();

            // 8. Collision Detection and Hit Stun (Player attacking AI)
            if (
                player1.isAttacking &&
                rectangularCollision({ rectangle1: player1, rectangle2: player2 })
            ) {
                player2.takeHit();
                player1.isAttacking = false; 
            }

            // 9. Collision Detection and Hit Stun (AI attacking Player)
            if (
                player2.isAttacking &&
                rectangularCollision({ rectangle1: player2, rectangle2: player1 })
            ) {
                player1.takeHit();
                player2.isAttacking = false; 
            }

            // 10. Restore canvas (removes the translation)
            ctx.restore();

            // 11. End Game Check (Health)
            if (player1.health <= 0 || player2.health <= 0) {
                determineWinner({ player1, player2 });
            }
        }

        // Start the game when the window loads
        window.onload = function () {
            // Set font for STUN message
            ctx.font = "24px 'Inter'"; 
            ctx.textAlign = 'center';

            decreaseTimer();
            animate();
        };

    </script>
</body>
</html>
